package com.eholee.lobster.compiler;

import com.eholee.lobster.annotation.AppInstance;
import com.eholee.lobster.annotation.ModuleApp;
import com.eholee.lobster.annotation.ShellApp;
import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.TreeTranslator;
import com.sun.tools.javac.util.List;
import com.sun.tools.javac.util.ListBuffer;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
/**
 * Author:Jeffer
 * Time:2020/12/16  11:04 PM  Wednesday
 * Description:注解处理器
 */
@SupportedAnnotationTypes({"com.eholee.lobster.annotation.ShellApp" , "com.eholee.lobster.annotation.ModuleApp" , "com.eholee.lobster.annotation.AppInstance" })
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(javax.annotation.processing.Processor.class)
public class LobsterProcessor extends BaseProcessor {

    private static final String onCreate = "onCreate";
    private static final String onConfigurationChanged = "invokeOnConfigurationChanged";
    private static final String onLowMemory = "invokeOnLowMemory";
    private static final String onTrimMemory = "invokeOnTrimMemory";
    private static final String attachBaseContext = "attachBaseContext";
    private Set<? extends Element> shellApps;
    private Set<? extends Element> moduleApps;
    private Set<? extends Element> appInstances;
    private static final String LOBSTER_DOC = "DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY LOBSTER.";
    private String applicationStatement;

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnv) {
        shellApps = roundEnv.getElementsAnnotatedWith(ShellApp.class);
        moduleApps = roundEnv.getElementsAnnotatedWith(ModuleApp.class);
        appInstances = roundEnv.getElementsAnnotatedWith(AppInstance.class);

        for (Element shellApp : shellApps) {
            generateMainAppJavaFile(shellApp);
        }

        for (Element moduleApp : moduleApps) {
            generateModuleAppJavaFile(moduleApp);
        }
        return true;
    }

    /**
     *在壳子模块（主工程）中生成代码
     * @param shellApp
     */
    private void generateMainAppJavaFile(Element shellApp) {
        JCTree jcTree = trees.getTree(shellApp);
        jcTree.accept(new TreeTranslator(){
            @Override
            public void visitMethodDef(JCTree.JCMethodDecl jcMethodDecl) {
                super.visitMethodDef(jcMethodDecl);
                switch (jcMethodDecl.name.toString()) {
                    case onCreate:
                        messager.printMessage(Diagnostic.Kind.NOTE, jcMethodDecl.name.toString());
                        invokeLobsterInitialize(jcMethodDecl , onCreate);
                        break;

                    case attachBaseContext:
                        // 可在此添加关于attachBaseContext代码
                        break;
                }
            }
        });

        generateLobsterJavaFile();
        generateClassUtil();
        generateThreadPool();
        generateThreadFactory();
    }

    /**
     * 生成DefaultThreadFactory类
     * 线程工厂
     */
    private void generateThreadFactory() {
        FieldSpec poolNumber = FieldSpec.builder(AtomicInteger.class , "poolNumber")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC, Modifier.FINAL)
                .initializer("new $T(1)" , AtomicInteger.class)
                .build();

        FieldSpec threadNumber = FieldSpec.builder(AtomicInteger.class , "threadNumber")
                .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
                .initializer("new $T(1)" , AtomicInteger.class)
                .build();

        FieldSpec group = FieldSpec.builder(ThreadGroup.class , "group")
                .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
                .build();

        FieldSpec namePrefix = FieldSpec.builder(String.class , "namePrefix")
                .addModifiers(Modifier.PRIVATE,Modifier.VOLATILE)
                .build();

        ParameterSpec runnable = ParameterSpec.builder(Runnable.class , "runnable").build();
        ParameterSpec threadName = ParameterSpec.builder(String.class , "threadName").build();
        MethodSpec newThread = MethodSpec.methodBuilder("newThread")
                .addModifiers(Modifier.PUBLIC )
                .addParameter(runnable)
                .returns(Thread.class)
                .addStatement("String "+threadName.name+" = $S.concat($T.valueOf(threadNumber.getAndIncrement()))" ,namePrefix.name  , String.class)
                .addStatement("Thread thread = new Thread("+group.name+" , "+runnable.name+" ,"+threadName.name+", 0)")
                .addStatement("if(thread.isDaemon()){ thread.setDaemon(false);}")
                .addStatement("return thread")
                .build();


        MethodSpec constructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addStatement("$T s = $T.getSecurityManager()" ,SecurityManager.class , System.class)
                .addStatement(group.name +" = ( s != null) ? s.getThreadGroup() : $T.currentThread().getThreadGroup()" , Thread.class)
                .addStatement(namePrefix.name +" = $S.concat($T.valueOf(poolNumber.getAndIncrement())).concat($S)" ,"Lobster task pool No." , String.class,", thread No.")
                .build();


        TypeSpec defaultThreadFactory = TypeSpec.classBuilder("DefaultThreadFactory")
                .addSuperinterface(ThreadFactory.class)
                .addModifiers(Modifier.PUBLIC)
                .addField(poolNumber)
                .addField(threadNumber)
                .addField(group)
                .addField(namePrefix)
                .addMethod(constructor)
                .addMethod(newThread)
                .addJavadoc(LOBSTER_DOC)
                .build();
        JavaFile javaFile = JavaFile.builder("com.eholee.lobster.main_app", defaultThreadFactory)
                .build();
        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 生成DefaultPoolExecutor 类
     * 用于检索指定包名下所有的类事务的多线程处理
     */
    private void generateThreadPool() {

        FieldSpec cpu_count = FieldSpec.builder(int.class , "CPU_COUNT")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.FINAL)
                .initializer("$T.getRuntime().availableProcessors()" , Runtime.class)
                .build();

        FieldSpec init_thread_count = FieldSpec.builder(int.class , "INIT_THREAD_COUNT")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.FINAL)
                .initializer("CPU_COUNT + 1")
                .build();

        FieldSpec max_thread_count = FieldSpec.builder(int.class , "MAX_THREAD_COUNT")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.FINAL)
                .initializer("INIT_THREAD_COUNT")
                .build();

        FieldSpec surplus_thread_life = FieldSpec.builder(Long.class , "SURPLUS_THREAD_LIFE")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.FINAL)
                .initializer("30L")
                .build();

        FieldSpec defaultPoolExecutor = FieldSpec.builder(ClassName.get("com.eholee.lobster.main_app" , "DefaultPoolExecutor") , "defaultPoolExecutor")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.VOLATILE)
                .build();

        MethodSpec getInstance = MethodSpec.methodBuilder("getInstance")
                .addModifiers(Modifier.PUBLIC , Modifier.STATIC)
                .returns(ClassName.get("com.eholee.lobster.main_app" ,"DefaultPoolExecutor"))
                .addStatement("if(null == "+defaultPoolExecutor.name+"){synchronized(DefaultPoolExecutor.class){if(null == "+defaultPoolExecutor.name+"){"+defaultPoolExecutor.name+"= new DefaultPoolExecutor("+init_thread_count.name+", "+max_thread_count.name+","+surplus_thread_life.name+",$T.SECONDS, new $T<Runnable>(64),new $T())" , TimeUnit.class , ArrayBlockingQueue.class , ClassName.get("com.eholee.lobster.main_app" , "DefaultThreadFactory"))
                .addStatement("}}}")
                .addStatement("return "+defaultPoolExecutor.name)
                .build();

        ParameterSpec c_corePoolSize = ParameterSpec.builder(int.class , "corePoolSize").build();
        ParameterSpec c_maximumPoolSize = ParameterSpec.builder(int.class , "maximumPoolSize").build();
        ParameterSpec c_keepAliveTime = ParameterSpec.builder(Long.class , "keepAliveTime").build();
        ParameterSpec c_unit = ParameterSpec.builder(TimeUnit.class , "unit").build();
        ParameterSpec c_workQueue = ParameterSpec.builder(BlockingQueue.class , "workQueue").build();
        ParameterSpec c_threadFactory = ParameterSpec.builder(ThreadFactory.class , "threadFactory").build();
        MethodSpec constructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PRIVATE)
                .addParameter(c_corePoolSize)
                .addParameter(c_maximumPoolSize)
                .addParameter(c_keepAliveTime)
                .addParameter(c_unit)
                .addParameter(c_workQueue)
                .addParameter(c_threadFactory)
                .addStatement("super("+c_corePoolSize.name+","+c_maximumPoolSize.name+","+c_keepAliveTime.name+","+c_unit.name+","+c_workQueue.name+","+ c_threadFactory.name+",new $T(){" +
                        "public void rejectedExecution($T r, $T executor){}})" , RejectedExecutionHandler.class ,  Runnable.class , ThreadPoolExecutor.class)
                .build();

        TypeSpec defaultPoolExecutorClass = TypeSpec.classBuilder("DefaultPoolExecutor")
                .addModifiers(Modifier.PUBLIC)
                .addField(cpu_count)
                .addField(init_thread_count)
                .addField(max_thread_count)
                .addField(surplus_thread_life)
                .addField(defaultPoolExecutor)
                .addMethod(constructor)
                .addMethod(getInstance)
                .addJavadoc(LOBSTER_DOC)
                .superclass(ThreadPoolExecutor.class)
                .build();
        JavaFile javaFile = JavaFile.builder("com.eholee.lobster.main_app", defaultPoolExecutorClass)
                .build();
        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 生成ClassUtil类
     * 主要用于检索指定包名下所有的类
     */
    private void generateClassUtil() {
        FieldSpec tag = FieldSpec.builder(String.class, "TAG")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", "lobster")
                .build();

        FieldSpec eXTRACTED_NAME_EXT = FieldSpec.builder(String.class, "EXTRACTED_NAME_EXT")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", ".classes")
                .build();

        FieldSpec eXTRACTED_SUFFIX = FieldSpec.builder(String.class, "EXTRACTED_SUFFIX")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", ".zip")
                .build();

        FieldSpec sECONDARY_FOLDER_NAME = FieldSpec.builder(String.class, "SECONDARY_FOLDER_NAME")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S+$T.separator+$S", "code_cache", File.class, "secondary-dexes")
                .build();

        FieldSpec pREFS_FILE = FieldSpec.builder(String.class, "PREFS_FILE")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", "multidex.version")
                .build();

        FieldSpec kEY_DEX_NUMBER = FieldSpec.builder(String.class, "KEY_DEX_NUMBER")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", "dex.number")
                .build();


        FieldSpec vM_WITH_MULTIDEX_VERSION_MAJOR = FieldSpec.builder(int.class, "VM_WITH_MULTIDEX_VERSION_MAJOR")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("2")
                .build();

        FieldSpec vM_WITH_MULTIDEX_VERSION_MINOR = FieldSpec.builder(int.class, "VM_WITH_MULTIDEX_VERSION_MINOR")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("1")
                .build();
        ParameterSpec context = ParameterSpec.builder(ClassName.get("android.content", "Context"), "context").build();
        MethodSpec getMultiDexPreferences = MethodSpec.methodBuilder("getMultiDexPreferences")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .addParameter(context)
                .returns(ClassName.get("android.content", "SharedPreferences"))
                .addStatement("return context.getSharedPreferences("+pREFS_FILE.name+" , $T.VERSION.SDK_INT<$T.VERSION_CODES.HONEYCOMB ? $T.MODE_PRIVATE : $T.MODE_PRIVATE | $T.MODE_MULTI_PROCESS)" ,
                        ClassName.get("android.os" , "Build") ,
                        ClassName.get("android.os" , "Build") ,
                        ClassName.get("android.content" , "Context") ,
                        ClassName.get("android.content" , "Context") ,
                        ClassName.get("android.content" , "Context")
                )
                .build();


        ParameterSpec context2 = ParameterSpec.builder(ClassName.get("android.content", "Context"), "context").build();
        ParameterSpec packageName = ParameterSpec.builder(String.class, "packageName").addModifiers(Modifier.FINAL).build();
        TypeName classes = ParameterizedTypeName.get(ClassName.get(java.util.List.class) , ClassName.get(String.class));

        ParameterSpec path = ParameterSpec.builder(String.class  , "path").build();
        MethodSpec getFileNameByPackageName = MethodSpec.methodBuilder("getFileNameByPackageName")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addParameter(context2)
                .addParameter(packageName)
                .addException(ClassName.get("android.content.pm.PackageManager" ,"NameNotFoundException"))
                .addException(IOException.class)
                .addException(InterruptedException.class)
                .returns(classes)
                .addStatement("final List<String> classNames = new $T<String>()" , ArrayList.class)
                .addStatement("$T<String> paths = getSourcePaths("+context2.name+")" , java.util.List.class)
                .addStatement("final $T parserCtl = new $T(paths.size())" , CountDownLatch.class , CountDownLatch.class)
                .addStatement("for(final String "+path.name+" : paths){$T.getInstance().execute(new $T(){public void run(){" +
                                "$T dexfile = null;" +
                                "try{" +
                                "if(path.endsWith("+eXTRACTED_SUFFIX.name+")){ dexfile = $T.loadDex("+path.name+", "+path.name+" + \".tmp\", 0);}else{" +
                                "dexfile = new DexFile("+path.name+");}" +
                                "$T<String> dexEntries = dexfile.entries();while(dexEntries.hasMoreElements()){" +
                                "String className = dexEntries.nextElement(); if (className.startsWith("+packageName.name+")&&!classNames.contains(className)){" +
                                "classNames.add(className);}}}catch($T ignore){}finally{if (null != dexfile) {try{dexfile.close();}catch($T ignore){}}parserCtl.countDown();}" +
                                "}});" +
                                "}" , ClassName.get("com.eholee.lobster.main_app" , "DefaultPoolExecutor") ,
                        Runnable.class ,
                        ClassName.get("dalvik.system" , "DexFile"),
                        ClassName.get("dalvik.system" , "DexFile"),
                        Enumeration.class,
                        Throwable.class,
                        Throwable.class
                )
                .addStatement("parserCtl.await();")
                .beginControlFlow("try")
                .addStatement("classNames.sort(new $T<String>() { public int compare(String o1, String o2) {" +
                        " int priority1 = $T.parseInt(o1.substring(o1.lastIndexOf(\"_\")+1));" +
                        " int priority2 = $T.parseInt(o2.substring(o2.lastIndexOf(\"_\")+1));" +
                        "if (priority1<priority2){\n" +
                        "                    return 1;" +
                        " }else if (priority1>priority2){\n" +
                        "                    return -1;\n" +
                        "                } return 0;}})" , Comparator.class , Integer.class , Integer.class)
                .endControlFlow()
                .beginControlFlow("catch($T ignore)" , Exception.class)
                .endControlFlow()
                .addStatement("return classNames")
                .build();

        MethodSpec isYunOS = MethodSpec.methodBuilder("isYunOS")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .returns(boolean.class)
                .beginControlFlow("try")
                .addStatement("String version = $T.getProperty(\"ro.yunos.version\")" , System.class)
                .addStatement("String vmName = $T.getProperty(\"java.vm.name\")", System.class)
                .addStatement("return (vmName != null && vmName.toLowerCase().contains(\"lemur\"))||(version != null && version.trim().length() > 0)" )
                .endControlFlow()
                .beginControlFlow("catch($T ignore)", Exception.class)
                .addStatement("return false")
                .endControlFlow()
                .build();

        MethodSpec isVMMultidexCapable = MethodSpec.methodBuilder("isVMMultidexCapable")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .returns(boolean.class)
                .addStatement("boolean isMultidexCapable = false")
                .addStatement("String vmName = null")
                .beginControlFlow("try")
                .beginControlFlow("if(isYunOS())")
                .addStatement("vmName = \"'YunOS'\"")
                .addStatement("isMultidexCapable = $T.valueOf($T.getProperty($S)) >= 21" , Integer.class, System.class , "ro.build.version.sdk")
                .endControlFlow()
                .beginControlFlow("else")
                .addStatement("vmName = \"'Android'\";")
                .addStatement("String versionString = $T.getProperty($S)" , System.class , "java.vm.version")
                .beginControlFlow("if(versionString != null)")
                .addStatement("$T matcher = $T.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString)" , Matcher.class , Pattern.class)
                .beginControlFlow("if (matcher.matches())")
                .beginControlFlow("try")
                .addStatement("int major = $T.parseInt(matcher.group(1))" , Integer.class)
                .addStatement("int minor = $T.parseInt(matcher.group(2))" , Integer.class)
                .addStatement("isMultidexCapable = (major > "+vM_WITH_MULTIDEX_VERSION_MAJOR.name+")||((major == "+vM_WITH_MULTIDEX_VERSION_MAJOR.name+")&&(minor >= "+vM_WITH_MULTIDEX_VERSION_MINOR.name+"))" , Integer.class)
                .endControlFlow()
                .beginControlFlow("catch($T ignore)", NumberFormatException.class)
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .beginControlFlow("catch($T ignore)", Exception.class)
                .endControlFlow()
                .addStatement("return isMultidexCapable")
                .build();

        ParameterSpec context3 = ParameterSpec.builder(ClassName.get("android.content", "Context"), "context").build();
        TypeName sourcePath = ParameterizedTypeName.get(ClassName.get(java.util.List.class) , ClassName.get(String.class));

        MethodSpec getSourcePaths = MethodSpec.methodBuilder("getSourcePaths")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addParameter(context3)
                .addException(ClassName.get("android.content.pm.PackageManager" , "NameNotFoundException"))
                .addException(IOException.class)
                .returns(sourcePath)
                .addStatement("$T applicationInfo = context.getPackageManager().getApplicationInfo(context.getPackageName(), 0)" , ClassName.get("android.content.pm" ,"ApplicationInfo"))
                .addStatement("$T sourceApk = new File(applicationInfo.sourceDir)" , File.class)
                .addStatement("List<String> sourcePaths = new $T<>()" , ArrayList.class)
                .addStatement("sourcePaths.add(applicationInfo.sourceDir)")
                .addStatement("String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT")
                .beginControlFlow("if(!isVMMultidexCapable())")
                .addStatement("int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1)")
                .addStatement("File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME)")
                .beginControlFlow("for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++)")
                .addStatement("String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX")
                .addStatement(" File extractedFile = new File(dexDir, fileName)")
                .beginControlFlow("if (extractedFile.isFile())")
                .addStatement("sourcePaths.add(extractedFile.getAbsolutePath())")
                .endControlFlow()
                .beginControlFlow("else")
                .addStatement("throw new $T(\"Missing extracted secondary dex file '\" + extractedFile.getPath() + \"'\")" , IOException.class)
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .addStatement("return sourcePaths")
                .build();


        TypeSpec classUtil = TypeSpec.classBuilder("ClassUtil")
                .addModifiers(Modifier.PUBLIC)
                .addField(tag)
                .addField(eXTRACTED_NAME_EXT)
                .addField(eXTRACTED_SUFFIX)
                .addField(sECONDARY_FOLDER_NAME)
                .addField(pREFS_FILE)
                .addField(kEY_DEX_NUMBER)
                .addField(vM_WITH_MULTIDEX_VERSION_MAJOR)
                .addField(vM_WITH_MULTIDEX_VERSION_MINOR)
                .addMethod(isYunOS)
                .addMethod(isVMMultidexCapable)
                .addMethod(getMultiDexPreferences)
                .addMethod(getSourcePaths)
                .addMethod(getFileNameByPackageName)
                .addJavadoc(LOBSTER_DOC)
                .build();
        JavaFile javaFile = JavaFile.builder("com.eholee.lobster.main_app", classUtil)
                .build();
        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * 生成Lobster类
     * 该类主要执行com.eholee.lobster.app包名下所有的类的检索，
     * 并按照优先级priority执行调用每个类的onCreate方法和application的赋值
     */
    private void generateLobsterJavaFile() {
        FieldSpec all_package_name = FieldSpec.builder(String.class , "ALL_APP_PACKAGE")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.FINAL)
                .initializer("$S" , "com.eholee.lobster.app")
                .build();

        FieldSpec app_oncreate = FieldSpec.builder(String.class , "APP_ONCREATE")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.FINAL)
                .initializer("$S" , "onCreate")
                .build();

        FieldSpec instance = FieldSpec.builder(ClassName.get("com.eholee.lobster.main_app" ,"Lobster") , "INSTANCE")
                .addModifiers(Modifier.PRIVATE,Modifier.STATIC , Modifier.VOLATILE)
                .build();

        TypeName classes = ParameterizedTypeName.get(ClassName.get(java.util.List.class) , ClassName.get(String.class));
        FieldSpec fileNameByPackageName = FieldSpec.builder(classes, "fileNameByPackageName")
                .addModifiers(Modifier.PRIVATE)
                .build();

        MethodSpec getInstance = MethodSpec.methodBuilder("getInstance")
                .addModifiers(Modifier.PUBLIC , Modifier.STATIC)
                .returns(ClassName.get("com.eholee.lobster.main_app" ,"Lobster"))
                .addStatement("if(null == "+instance.name+"){synchronized(Lobster.class){if(null == "+instance.name+"){"+instance.name+"= new Lobster()")
                .addStatement("}}}")
                .addStatement("return "+instance.name)
                .build();

        MethodSpec constructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PRIVATE)
                .build();
        ParameterSpec context = ParameterSpec.builder(ClassName.get("android.content" ,"Context") , "context").build();
        ParameterSpec appFileName = ParameterSpec.builder(String.class , "appFileName").build();
        ParameterSpec clazzObj = ParameterSpec.builder(Object.class , "clazzObj").build();
        MethodSpec init = MethodSpec.methodBuilder("init")
                .addModifiers(Modifier.PUBLIC )
                .addParameter(context)
                .returns(void.class)
                .addStatement("try{"+fileNameByPackageName.name+" =$T.getFileNameByPackageName("+context.name+","+all_package_name.name+")",ClassName.get("com.eholee.lobster.main_app" ,"ClassUtil"))
                .addStatement("for(String "+appFileName.name+" : "+fileNameByPackageName.name+"){")
                .addStatement("try{Class<?> clazz = $T.forName("+appFileName.name+")" , Class.class)
                .addStatement("Object "+clazzObj.name+" = clazz.newInstance()")
                .addStatement("$T field = clazz.getDeclaredField($S)" , Field.class , "application")
                .addStatement("field.setAccessible(true)")
                .addStatement("field.set("+clazzObj.name+", "+context.name+")")
                .addStatement("$T method = clazz.getDeclaredMethod($S)" , Method.class , "onCreate")
                .addStatement("method.setAccessible(true)")
                .addStatement("method.invoke("+clazzObj.name+")")
                .addStatement("}catch($T ignore){}}}catch($T.NameNotFoundException | $T | $T e){}" , Exception.class , ClassName.get("android.content.pm" , "PackageManager")  ,IOException.class , InterruptedException.class )
                .build();

        TypeSpec lobster = TypeSpec.classBuilder("Lobster")
                .addModifiers(Modifier.PUBLIC)
                .addField(all_package_name)
                .addField(app_oncreate)
                .addField(instance)
                .addField(fileNameByPackageName)
                .addMethod(constructor)
                .addMethod(getInstance)
                .addMethod(init)
                .addJavadoc(LOBSTER_DOC)
                .build();



        JavaFile javaFile = JavaFile.builder("com.eholee.lobster.main_app", lobster)
                .build();
        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * 生成ModuleApp模块的java代码
     * 主要生成RefelectAppLifecycler_$moduleName_$priority类
     * moduleName 从 模块的build.gradle 配置中读取option参数 ， 代表名称
     * priority 从被ModuleApp注解中读取， 代表该Application执行的优先级
     * 该类会反射调用模块中被ModuleApp注解的Application的onCreate方法并赋值主工程的Application引用给被AppInstance注解的字段
     * @param moduleApp
     */
    private void generateModuleAppJavaFile(Element moduleApp) {
        applicationStatement = null;
        String  fullClass = moduleApp.getEnclosingElement().toString().concat(".").concat(moduleApp.getSimpleName().toString());
        ModuleApp moduleAppClazz = moduleApp.getAnnotation(ModuleApp.class);
        for (Element appInstance : appInstances) {
            String className = appInstance.getEnclosingElement().toString();
            if (className.equals(fullClass)){
                // 是当前module的appInstance
                JCTree jcAppInstanceTree = trees.getTree(appInstance);
                jcAppInstanceTree.accept(new TreeTranslator(){
                    @Override
                    public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
                        super.visitVarDef(jcVariableDecl);
                        applicationStatement = fullClass.concat(".").concat(jcVariableDecl.name.toString());
                    }
                });
            }
        }
        int priority = moduleAppClazz.priority();

        FieldSpec fieldSpec = FieldSpec.builder(String.class , "onCreate")
                .addModifiers(Modifier.PRIVATE , Modifier.STATIC , Modifier.FINAL)
                .initializer("$S" , "onCreate")
                .build();

        String moduleAppInstanceFieldName =  "application";
        FieldSpec appFieldSpec = FieldSpec.builder(ClassName.get("android.app" ,"Application"),moduleAppInstanceFieldName)
                .addModifiers(Modifier.PRIVATE , Modifier.STATIC)
                .build();

        MethodSpec onCreateMethod = MethodSpec.methodBuilder("onCreate")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .returns(void.class)

                .addStatement(applicationStatement==null ?"":applicationStatement+" = "+ moduleAppInstanceFieldName)
                .beginControlFlow("try")
                .addStatement("Class<?> clazz = $T.forName($S)" , Class.class , fullClass)
                .addStatement("$T method = clazz.getDeclaredMethod(onCreate)" , Method.class)
                .addStatement("method.setAccessible(true)")
                .addStatement("method.invoke(clazz.newInstance())")
                .endControlFlow()
                .beginControlFlow("catch($T ignore)" ,Exception.class)
                .endControlFlow()
                .build();
        TypeSpec appLifecycler = TypeSpec.classBuilder("RefelectAppLifecycler".concat("_").concat(classNameSuffix).concat("_").concat(String.valueOf(priority)))
                .addModifiers(Modifier.PUBLIC)
                .addField(appFieldSpec)
                .addField(fieldSpec)
                .addMethod(onCreateMethod)
                .addJavadoc(LOBSTER_DOC)
                .build();
        JavaFile javaFile = JavaFile.builder("com.eholee.lobster.app", appLifecycler)
                .build();
        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    /**
     * Lobster 初始化代码 , 在被ShellApp注解的Application的onCreate方法中植入代码  Lobster.getInstance().init(this);
     * @param jcMethodDecl
     * @param onCreate
     */
    private void invokeLobsterInitialize(JCTree.JCMethodDecl jcMethodDecl, String onCreate) {
        ListBuffer<JCTree.JCStatement> onCreateBuffer = new ListBuffer<>();
        onCreateBuffer.append( jcMethodDecl.body);
        //  声明变量
        JCTree.JCVariableDecl var_lobster = treeMaker.VarDef(
                treeMaker.Modifiers(0), //访问标志！
                names.fromString("lobster"), //名字
                ProcessorUtil.memberAccess(treeMaker , names , "com.eholee.lobster.main_app.Lobster"), //类型
                null); //初始化语句

        // 生成方法调用语句  Lobster.getInstance();
        JCTree.JCExpressionStatement getInstanceStatement = treeMaker.Exec(treeMaker.Apply(
                //参数类型
                List.nil(),
                //方法调用
                ProcessorUtil.memberAccess(treeMaker , names , names.fromString("com.eholee.lobster.main_app.Lobster".concat(".").concat("getInstance")).toString()),
                //实参
                List.nil()
                )
        );
        // 生成赋值语句  lobster = Lobster.getInstance();
        JCTree.JCExpressionStatement lobsterAssignStatement= treeMaker.Exec(
                treeMaker.Assign(
                        treeMaker.Ident(var_lobster.name),
                        getInstanceStatement.getExpression()
                )
        );

        // 生成方法调用语句  lobster.init(this);
        JCTree.JCExpressionStatement lobsterInvoke = treeMaker.Exec(treeMaker.Apply(
                //参数类型
                List.of(ProcessorUtil.memberAccess(treeMaker ,names ,"android.content.Context")),
                //方法调用
                ProcessorUtil.memberAccess(treeMaker , names , names.fromString("lobster".concat(".").concat("init")).toString()),
                //实参
                List.of(treeMaker.Ident(names.fromString("this")))
                )
        );


        onCreateBuffer.append(var_lobster);
        onCreateBuffer.append(lobsterAssignStatement);
        onCreateBuffer.append(lobsterInvoke);

        jcMethodDecl.body = treeMaker.Block(0 , onCreateBuffer.toList());

        messager.printMessage(Diagnostic.Kind.NOTE , "编译后主工程Application的onCreate代码:"+jcMethodDecl.body);

    }

}
